{"pageProps":{"post":{"title":"Web 前端性能指标","date":"2019-08-28T12:34:00.000Z","slug":"web-performance-metrics","content":"<h2>性能分类</h2>\n<h3>加载性能</h3>\n<p>请求资源时会受设备、浏览器、协议、网络类型和延迟等影响（CDN，ISP，缓存，代理，防火墙，负载均衡器和服务器）。</p>\n<ul>\n<li>\n<p>首次绘制（FP，First Paint）</p>\n<p>  标记浏览器渲染任何在视觉上不同于导航前屏幕内容的时间点。</p>\n</li>\n<li>\n<p>首次内容绘制（FCP，First Contentful Paint）</p>\n<p>  标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像等元素。</p>\n</li>\n<li>\n<p>首次有效绘制（FMP，First Meaningful Paint）</p>\n<p>  标记浏览器已渲染出可以与用户互动的足够内容。每个网站对“哪些部分对用户最为有用”都有自己的定义。</p>\n</li>\n<li>\n<p>主角元素计时（Hero Element Timing）</p>\n<p>  网页的这些“最重要部分”通常称为主角元素。例如，在新闻网站上，主角元素可能是重大新闻和置顶大图。</p>\n<p>  在网页上，几乎总有一部分内容比其他部分更重要。 如果页面最重要的部分能迅速加载，用户可能不会注意到其余部分是否加载。</p>\n</li>\n<li>\n<p>耗时较长的任务（Long Tasks）</p>\n<p>  浏览器是单线程，通过将任务添加到主线程上的队列等待逐个执行来响应用户输入。在某些情况下，运行这些任务可能要花费较长时间，这时主线程就会被阻塞，而队列中的所有其他任务都必须等待。</p>\n<p>  应用有 100 毫秒的时间响应用户输入。如果超过此时间，用户就会认为应用反应迟缓。要实现小于 100 毫秒的响应，应用必须在每 50 毫秒内将控制返回给主线程，这样应用就可以执行其像素管道、对用户输入作出反应，等等。<a href=\"https://w3c.github.io/longtasks/\">Long Tasks API</a> 可以将任何耗时超过 50 毫秒的任务标示为可能存在问题，并向应用开发者显示这些任务。</p>\n</li>\n<li>\n<p>可交互时间（TTI，Time to Interactive）</p>\n<p>  标记应用已进行视觉渲染并能可靠响应用户输入的时间点。TTI 指标可识别页面初始 JavaScript 已加载且主线程处于空闲状态（没有耗时较长的任务）的时间点。</p>\n</li>\n<li>\n<p>速度指标（Speed Index）</p>\n<p>  表明网页填充页面内容的速度，分数越低越好。</p>\n</li>\n<li>\n<p>首次 CPU 闲置时间（First CPU Idle）</p>\n<p>  首次 CPU 闲置时间，标记了网页的主线程首次有空处理输入操作的时间。</p>\n</li>\n<li>\n<p>潜在最久的首次交互延迟（Max Potential First Input Delay）</p>\n<p>  测量用户首次与网站交互时（比如点击链接）到浏览器实际能够回应这次互动的时间范围，以毫秒为单位。</p>\n</li>\n</ul>\n<p><img src=\"/medias/web-performance-metrics/15670793115798.jpg\"></p>\n<blockquote>\n<p>上述大部分指标可直接使用 <a href=\"https://developers.google.com/web/tools/lighthouse/\">Lighthouse</a> 获取。</p>\n<p><img src=\"/medias/web-performance-metrics/15671320426962.jpg\"></p>\n</blockquote>\n<h3>渲染性能</h3>\n<p>目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。</p>\n<p>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动，造成卡顿。</p>\n<h4>像素管道</h4>\n<p>像素至屏幕管道中的关键点：</p>\n<p><img src=\"/medias/web-performance-metrics/frame-full.jpg\" alt=\"完整的像素管道\"></p>\n<ul>\n<li><strong>JavaScript</strong>。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 <code>animate</code> 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</li>\n<li><strong>样式计算</strong>。此过程是根据匹配选择器（例如 <code>.headline</code> 或 <code>.nav > .nav__item</code>）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</li>\n<li><strong>布局</strong>。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 <code>&#x3C;body></code> 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</li>\n<li><strong>绘制</strong>。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。绘制实际上分为两个任务： 1) 创建绘图调用的列表，以及 2) 填充像素（常称为“栅格化”）。</li>\n<li><strong>合成</strong>。由于页面的各部分可能被绘制到多层，因此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</li>\n</ul>\n<p>管道的每个部分都有机会产生卡顿，因此需准确了解代码触发管道的哪些部分。</p>\n<h2>性能测试</h2>\n<p>性能需要被测量、监测和完善。</p>\n<h3>实验数据（Lab data）</h3>\n<p>在开发人员可控的环境中（使用指定的设备和网络等）收集的性能数据。</p>\n<h4>优点</h4>\n<ol>\n<li>利于 Debug 性能问题</li>\n<li>开发人员可亲身感受到实际的体验</li>\n<li>测试环境可复用，测试数据可作比对</li>\n</ol>\n<h4>缺点</h4>\n<ol>\n<li>无法体现实际用户的性能瓶颈</li>\n<li>无法与实际页面 KPI 相关联</li>\n</ol>\n<h4>工具</h4>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/lighthouse/\">Lighthouse</a></li>\n<li><a href=\"https://www.webpagetest.org/\">WebPageTest</a></li>\n<li><a href=\"https://developers.google.com/speed/pagespeed/insights\">PageSpeed Insights</a></li>\n<li><a href=\"https://gtmetrix.com\">Gtmetrix</a></li>\n<li>Chrome DevTools 等浏览器开发人员工具</li>\n</ul>\n<h3>现场数据（Field data）</h3>\n<p>也叫真实用户监测，RUM。是从用户的实际体验中捕获的性能数据。</p>\n<h4>优点</h4>\n<ol>\n<li>代表实际用户的体验结果</li>\n<li>可反映与业务关键绩效指标的相关性</li>\n<li>可监测到异常情况</li>\n</ol>\n<h4>缺点</h4>\n<ol>\n<li>可获取的指标数受限</li>\n<li>调试受限</li>\n</ol>\n<h4>工具</h4>\n<ul>\n<li><a href=\"https://newrelic.com/products/browser-monitoring\">New Relic</a></li>\n<li><a href=\"https://calibreapp.com\">Calibre</a></li>\n<li><a href=\"https://speedcurve.com\">SpeedCurve</a></li>\n<li>使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance\">Performance API</a> 实现简易的监测工具并发送数据到 Goolge Analytics</li>\n</ul>\n<h2>性能评估</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">体验</th>\n<th align=\"left\">反馈</th>\n<th align=\"left\">指标</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">是否发生？</td>\n<td align=\"left\">导航是否成功启动？服务器是否有响应？</td>\n<td align=\"left\">首次绘制 (FP)/首次内容绘制 (FCP)</td>\n</tr>\n<tr>\n<td align=\"left\">是否有用？</td>\n<td align=\"left\">是否已渲染可以与用户互动的足够内容？</td>\n<td align=\"left\">首次有效绘制 (FMP)/主角元素计时</td>\n</tr>\n<tr>\n<td align=\"left\">是否可用？</td>\n<td align=\"left\">用户可以与页面交互，还是页面仍在忙于加载？</td>\n<td align=\"left\">可交互时间 (TTI)</td>\n</tr>\n<tr>\n<td align=\"left\">是否令人愉快？</td>\n<td align=\"left\">交互是否顺畅而自然，没有滞后和卡顿？</td>\n<td align=\"left\">在技术上不存在耗时较长的任务</td>\n</tr>\n</tbody>\n</table>\n<h3>RAIL 模型</h3>\n<p>可使用 Google 的 <a href=\"https://developers.google.com/web/fundamentals/performance/rail\">RAIL</a> 模型评估性能。这是一种以用户为中心的性能模型，最终目标不是让网站在任何特定设备上都能运行很快，而是使用户满意。</p>\n<p><img src=\"/medias/web-performance-metrics/15664790709458.jpg\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">RAIL 步骤</th>\n<th align=\"left\">关键指标</th>\n<th align=\"left\">用户操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><strong>响应</strong></td>\n<td align=\"left\">输入延迟时间（从点按到绘制）小于 100 毫秒。</td>\n<td align=\"left\">用户点按按钮（例如打开导航）。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>动画</strong></td>\n<td align=\"left\">每个帧的工作（从 JS 到绘制）完成时间小于 16.66 毫秒。</td>\n<td align=\"left\">用户滚动页面，拖动手指（例如，打开菜单）或看到动画。 拖动时，应用的响应与手指位置有关（例如，拉动刷新、滑动轮播）。 此指标仅适用于拖动的持续阶段，不适用于开始阶段。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>空闲</strong></td>\n<td align=\"left\">主线程 JS 工作分成不大于 50 毫秒的块。</td>\n<td align=\"left\">用户没有与页面交互，但主线程应足够用于处理下一个用户输入。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>加载</strong></td>\n<td align=\"left\">页面可以在 1000 毫秒内就绪。</td>\n<td align=\"left\">用户加载页面并看到关键路径内容。</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>应用有 100 毫秒的时间响应用户输入。如果超过此时间，用户就会认为应用反应迟缓。</li>\n<li>每一帧动画应该要在 16.66 毫秒内完成，从而达到 60 帧每秒（1秒 ÷ 60 ≈ 16.66 毫秒）。但因为浏览器需要花费时间将新帧绘制到屏幕上，所以只有 10 毫秒来执行代码。</li>\n<li>有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。但也需根据实际情况减少预加载数据，以便应用快速加载，并利用空闲时间加载剩余数据。推迟的工作应分成每个耗时约 50 毫秒的多个块（要实现小于 100 毫秒的响应，应用必须在每 50 毫秒内将控制返回给主线程，这样应用就可以执行其像素管道、对用户输入作出反应，等等）。如果用户开始交互，优先级最高的事项是响应用户。</li>\n<li>在 1 秒钟内加载好网站。否则，用户的注意力会分散，他们处理任务的感觉会中断。无需在 1 秒内加载所有内容以产生完整加载的感觉。启用渐进式渲染和在后台执行一些工作。将非必需的加载推迟到空闲时间段。侧重于优化关键渲染路径以取消阻止渲染。</li>\n</ol>\n<h2>开发模式</h2>\n<h3>PRPL 模式</h3>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\">PRPL</a> 模式是一种用于结构化和提供 Progressive Web App (PWA) 的模式，该模式强调应用交付和启动的性能。 它代表：</p>\n<p>推送（Push）：为初始网址路由推送关键资源。\n渲染（Render）：渲染初始路由。\n预缓存（Precache）：预缓存剩余路由。\n延迟加载（Lazy Load）：延迟加载并按需创建剩余路由。</p>\n<h3>优化关键渲染路径</h3>\n<p>优化关键渲染路径是指优先显示与当前用户操作有关的内容。</p>\n<p><img src=\"/medias/web-performance-metrics/15664780941697.jpg\"></p>\n<h2>监测计划</h2>\n<h3>实验数据</h3>\n<p>开发完成后在各自的电脑上运行 Lighthouse 查看结果。</p>\n<h4>主要监测指标</h4>\n<ol>\n<li>首次内容绘制（FCP，First Contentful Paint）</li>\n<li>首次有效绘制（FMP，First Meaningful Paint）</li>\n<li>速度指标（Speed Index）</li>\n<li>首次 CPU 闲置时间（First CPU Idle）</li>\n<li>可交互时间（TTI，Time to Interactive）</li>\n<li>潜在最久的首次交互延迟（Max Potential First Input Delay）</li>\n</ol>\n<p>因测试结果受开发人员电脑配置等因素有关，换其他人的电脑可能会出现差异较大的结果，数据难以用作对照，因此主要用于监测明显不足的地方。</p>\n<h3>现场数据</h3>\n<p>上述提到收集现场数据的工具都需付费，也可考虑先投入开发简易的监测工具并发送数据到 Goolge Analytics 来做统计。</p>\n<hr>\n<p><em>参考资料：</em></p>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/\">Google Web Fundamentals\n</a></li>\n<li><a href=\"https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4\">The Cost Of JavaScript In 2018</a></li>\n</ul>\n","ogImage":{"url":""}}},"__N_SSG":true}